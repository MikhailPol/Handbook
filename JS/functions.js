


// Функции. Виды функций. Создание, объявления. this. call() apply() bind(). Arguments. Отличия.
// замыкание, рекурсия.
// 1.Виды функций. Создание, объявление.
/*
1)Функции-объявления - Function Declaration
*/
// function add(a, b) {
//    return a + b
// }
/*
2)Функции выражения (Function Expression)
*/
// const multiply = function(a, b) {
//    return a * b
// }
/*
3)Стрелочные функции (Arrow Functions)
*/
// const sum = (a, b) => {
//    return a + b
// }
/*
4)Функции конструкторы. new (Constructor Functions)
*/
// function Person(name, age) {
//    this.name = name;
//    this.age = age;
// }
// const person1 = new Person('person 1', 20);
/*
5)Методы объектов (Object Methods).
*/
// const person2 = {
//    name: 'person2',
//    age: 20,
//    sayHI: function() {
//       console.log(`Hi, a'm ${this.name}`)
//    }
// }
/*
6)Рекурсивные функции (Recursive Functions)
*/
// function factorial(n) {
//    if (n <= 1) {
//      return 1;
//    } else {
//      return n * factorial(n - 1);
//    }
// }
/*
7)Анонимные функции (Anonymous Functions)
*/
// const printMessage = function() {
//    console.log('Hello, world!');
// };

// 2.Ключевое слово this.
/*
В JavaScript ключевое слово this используется для ссылки на текущий контекст выполнения. Значение this зависит от того, каким образом и где вызывается функция.
1) Глобальный контекст: Если this используется вне функции или метода, то он ссылается на глобальный объект, который в браузере является window, а в Node.js - global.
*/
// console.log(this)
/*
2) Функция: По умолчанию this внутри обычной функции указывает на глобальный объект в нестрогом режиме и на undefined в строгом режиме.
*/
// "use strict"
// function sayHello() {
   // console.log(this); // window (в браузере), undefined (в строгом режиме)
// }
// sayHello();
/*
3) Метод объекта: Когда this используется в методе объекта, он ссылается на сам объект, в контексте которого вызывается метод.
*/
// const user = {
//    name: 'Mik',
//    greet: function() {
//       console.log(`Hi, ${this.name}`);
//    }
// };
// user.greet()
/*
4. Конструктор: Внутри конструктора this ссылается на экземпляр объекта, который создается при использовании оператора new.
*/
// function Person(name) {
//    this.name = name;
//    this.greet = function() {
//       console.log(`hi, ${this.name}`);
//    }
// };
// const mik = new Person('Mik');
// mik.greet();
// const john = new Person('John');
// john.greet();
/*
3. call()  | apply()  | bind() - используются для управления контекстом выполнения функции. Они позволяют явно указать значение this внутри функции.
Методы call() и apply() позволяют немедленно вызвать функцию с указанным значением this и аргументами. Разница между ними заключается в том, что call() принимает аргументы в виде списка, в то время как apply() принимает аргументы в виде массива.
1)call()
*/
// function sayHi() {
//    console.log(`Hi, ${this.name}`)
// }
// const mik = {name: 'Mik'};
// sayHi.call(mik);
/*
2)apply()
*/
// function sayHi(message) {
//    console.log(`${message}, ${this.name}`)
// }
// const mik = {name: 'Mik'};
// sayHi.apply(mik, ['Hello']);
/*
3) bind() - создает новую функцию, привязанную к определенному значению this. В отличие от call() и apply(), .bind() не вызывает функцию немедленно, а возвращает новую функцию с привязанным контекстом this.
*/
// function sayHi() {
//    console.log(`hi, ${this.name}`);
// }
// const mik = {name: 'Mik'};
// const hiMik = sayHi.bind(mik);
// hiMik();
// console.log(hiMik);
/*
4. arguments. Это специальный объект, доступный внутри каждой функции. Он содержит список всех аргументов, переданных в функцию при ее вызове, независимо от количества аргументов, указанных в объявлении функции.

Объект arguments имеет свойство length, которое указывает на количество аргументов, переданных в функцию.

Один из основных преимуществ объекта arguments заключается в том, что он позволяет создавать функции с переменным числом аргументов без явного указания их количества при объявлении функции.

Однако следует отметить, что arguments является объектом, но не массивом, поэтому он не обладает всеми методами и свойствами, характерными для массивов. Если вы хотите использовать методы массивов, вы можете преобразовать arguments в массив при помощи функций, таких как Array.from() или оператор spread ...
*/
// function sum() {
//    let total = 0;
//    for (let i = 0; i < arguments.length; i++) {
//       total += arguments[i];
//    }
//    return total;
// };
// console.log(sum(1,2,3,4,5,6));
// console.log(sum(14,24,312,2,55,23));

// function convertToArray() {
//    const argsArray = Array.from(arguments);
//    console.log(argsArray);
// }
// convertToArray(1,2,'a',false);
/*
5. Отличия Function Declaration от Function Expression
Ключевое отличие функции объявления от функции выражения состоит в том, что функции обьявления
в момент компиляции поднимаются наверх всего кода (HOISTING - поднятие), и к ним можно обратится
в любое время, главное что бы функция была. Функция выражения может быть вызвана только после того,
как была объявленна.

6.Отличие стрелочных функций от обычных (функций-конструкторов или функций, объявленных с помощью ключевого слова "function") в JavaScript заключается в синтаксисе и поведении.

1) Синтаксис:
   - Стрелочные функции имеют более краткий синтаксис по сравнению с обычными функциями. Они записываются в виде () => {}, где () - список параметров, => - стрелка, и {} - тело функции. Если функция принимает один параметр, можно опустить круглые скобки вокруг параметра.
   - Обычные функции имеют более длинный синтаксис. Они записываются в виде function () {}, где function - ключевое слово, () - список параметров и {} - тело функции.

2) Связывание контекста (this):
   - В стрелочной функции контекст (значение this`) берется из окружающего лексического контекста, в то время как у обычных функций значение `this может меняться в зависимости от того, как они вызываются.
   - В стрелочной функции значение this не может быть изменено с помощью методов call(), apply() или bind(), так как они не создают новое значение this.
   - В обычных функциях значение this определяется во время вызова функции и зависит от контекста вызова, например, объекта, на котором вызывается метод.
*/
// const mik = {
//    name: 'mik',
//    sayHi: function() {
//       console.log(`hi, ${this.name}`)
//    } // Обычная функция
// }
// mik.sayHi(); //hi, mik

// const mik = {
//    name: 'Mik',
//    sayHi: () => {
//       console.log(`hi, ${this.name}`);
//    } // Стрелочная функция
// }
// mik.sayHi(); //hi, undefined

// Сохраняем значение this в переменной.
// function myFunc() {
//    const self = this;
//    const myArrowFunc = () => {
//       console.log(self);
//    };
//    myArrowFunc();
// };

// const myObj = {
//    name: 'Mik',
//    myFunc: myFunc
// };
// myObj.myFunc();
/*
3) Невозможность использования конструктора:
   - Стрелочные функции не могут быть использованы как конструкторы для создания новых объектов. Это означает, что нельзя использовать оператор new для вызова стрелочной функции.
*/
// const constructorFunc = (name) => {
//    this.name = name
// }
// const mik = new constructorFunc('Mik'); //error;

// function constructorFunc(name) {
//    this.name = name;
// }
// const mik = new constructorFunc('mik'); //ok
/*
4) Невозможность использования ключевого слова "arguments":
   - В стрелочных функциях нет доступа к псевдомассиву arguments, который содержит все переданные аргументы функции.
   - Вместо этого, в стрелочных функциях следует использовать оператор ... (rest operator) для получения всех аргументов. Например, (...args) => {} будет получать все аргументы в виде массива args.
*/
// const arrFunc = () => {
//    let total = 0;
//    for (let i = 0; i < arguments.length; i++) {
//       total += arguments[i];
//    }
//    return total;
// }
// console.log(arrFunc(1,2,3)) //error;

// const arrFunc = (...numbers) => {
//    let total = 0;
//    for (let i = 0; i < numbers.length; i++) {
//       total += numbers[i];
//    }
//    return total;
// }
// console.log(arrFunc(1,2,3,4)) //ok, 10.
/*
6. Замыкание.
Замыкание (closure) в JavaScript - это комбинация функции и лексического окружения, в котором она была объявлена. В других словах, замыкание - это функция, которая имеет доступ к переменным из своего внешнего контекста, даже после завершения выполнения этого контекста.

Когда функция объявляется внутри другой функции, она получает доступ к переменным этой внешней функции и сохраняет ссылку на них в своем лексическом окружении. При этом замыкание может использовать эти переменные даже после того, как внешняя функция завершила свое выполнение.
*/
// function outerFunc() {
//    const outerVariable = 'example';
//    function innerFunc() {
//       console.log(outerVariable);
//    };
//    return innerFunc;
// }
// const closure = outerFunc();
// closure(); // example

// function counter() {
//    let count = 0;
//    return {
//       increment: function() {
//          count++;
//       },
//       decrement: function() {
//          count--;
//       },
//       reset: function() {
//          count = 0;
//       },
//       getCount: function() {
//          console.log(`count = ${count}`);
//       }
//    };
// }

// const count1 = counter(); //count = 0;
// count1.getCount() // count = 0;
// count1.increment() // count++
// count1.getCount() // count = 1;
// count1.increment() // count++;
// count1.getCount() // count = 2;
// count1.decrement() // count--;
// count1.getCount() // count = 1;
// count1.reset() // count = 0;
// count1.getCount() // count = 0;
// count1.increment() // count++;
// count1.getCount() // count = 1;
/*
7.Рекурсия.
Рекурсия в JavaScript означает вызов функции из самой себя. В процессе рекурсии функция может вызывать саму себя несколько раз, до достижения некоторого условия выхода из рекурсии. Обязательно должно быть условие завершения рекурсии(базовый случай), иначе функция будет вызываться до тех пор, пока не переполнится стек вызовов и будет выброшенна соответствующая ошибка.
*/

// function countDown(n) {
//    if (n <= 0) {
//       console.log('Done!');
//    } else {
//       console.log(n);
//       countDown(n - 1);
//    }
// }
// countDown(5); //5, 4, 3, 2, 1, Done!

// function factorial(n) {
//    if (n === 0) {
//      return 1;
//    } else {
//      return n * factorial(n - 1);
//    }
// }

// console.log(factorial(5));
/*
Для пояснения, разберем по порядку что будет происходить во время работы функции.
1. Первый вызов: factorial(5)
   - Условие n === 0 не выполнено, переходим к следующему шагу.
   - Выполняется рекурсивный вызов return 5 * factorial(4)
   
2. Рекурсивный вызов: factorial(4)
   - Условие n === 0 не выполнено, переходим к следующему шагу.
   - Выполняется рекурсивный вызов return 4 * factorial(3)
   
3. Рекурсивный вызов: factorial(3)
   - Условие n === 0 не выполнено, переходим к следующему шагу.
   - Выполняется рекурсивный вызов return 3 * factorial(2)
   
4. Рекурсивный вызов: factorial(2)
   - Условие n === 0 не выполнено, переходим к следующему шагу.
   - Выполняется рекурсивный вызов return 2 * factorial(1)
   
5. Рекурсивный вызов: factorial(1)
   - Условие n === 0 не выполнено, переходим к следующему шагу.
   - Выполняется рекурсивный вызов return 1 * factorial(0)

6. Рекурсивный вызов: factorial(0)
   - Условие n === 0 выполнено, возвращаем 1 (базовый случай)

Теперь начинается обратное вычисление:

7. Возвращается результат factorial(0), которое равно 1.
   Это значение умножается на 1 в выражении 1 * factorial(1), получаем 1.

8. Возвращается результат factorial(1), которое равно 1.
   Это значение умножается на 2 в выражении 2 * factorial(2), получаем 2.

9. Возвращается результат factorial(2), которое равно 2.
   Это значение умножается на 3 в выражении 3 * factorial(3), получаем 6.

10. Возвращается результат factorial(3), которое равно 6.
    Это значение умножается на 4 в выражении 4 * factorial(4), получаем 24.

11. Возвращается результат factorial(4), которое равно 24.
    Это значение умножается на 5 в выражении 5 * factorial(5), получаем 120.

В итоге, результат выполнения функции factorial(5) равен 120.

Советую использовать отладчик, что бы пошагово посмотреть стек вызовов и понять, как происходит 
рекурсия, если с первого раза тяжело понять.
*/