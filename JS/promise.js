/*
Промис (Promise) — специальный объект JavaScript, который используется для написания и обработки асинхронного кода.
Асинхронные функции возвращают объект Promise в качестве значения. Внутри промиса хранится результат вычисления, которое может быть уже выполнено или выполнится в будущем.

Промис может находиться в одном из трёх состояний:
  pending — стартовое состояние, операция стартовала;
  fulfilled — получен результат;
  rejected — ошибка.

Поменять состояние можно только один раз: перейти из pending либо в fulfilled, либо в rejected

У промиса есть методы then(), catch(), finally() которые позволяют использовать результат работы промиса.
----
  then() - Метод используют, чтобы выполнить код после изменения состояния промиса.
  Метод принимает два аргумента:
    onFulfill — функция-колбэк, которая будет вызвана при переходе промиса в состояние «успех» fulfilled. Функция имеет один параметр, в который передаётся результат выполнения операции
    onReject — функция-колбэк, которая будет вызвана при переходе промиса в состояние «ошибка» rejected. Функция имеет один параметр, в который передаётся информация об ошибке
  *** Так как then() всегда возвращает новый промис, то его удобно использовать для построения последовательностей асинхронных операций
  ***
----
  catch() - используют для обработки ошибки при выполнении асинхронной операции. Метод принимает один аргумент:
    onReject — функция-колбэк, которая будет вызвана при переходе промиса в состояние «ошибка» rejected. Функция имеет один параметр, в который передаётся информация об ошибке.
  *** Техническая деталь. Под капотом catch() содержит вызов then(), где первый колбэк установлен в undefined: catch(onReject) → then(undefined, onReject).
  ***
----
  finally() - используют для выполнения кода при завершении промиса. Код выполнится как при переходе промиса в состояние fulfilled, так и в rejected. Метод принимает один аргумент:
    onDone — функция-колбэк, которая будет вызвана при завершении промиса.
  *** Техническая деталь. Под капотом finally() — это вызов then(), где оба колбэка onDone: finally(onDone) → then(onDone, onDone).
  ***
----
*/

// function add(num1, num2) {                                      //Принимает 2 аргумента
//   return new Promise((resolve, reject) => {                     //Возвращает промис
//     if(typeof(num1) !== 'number' || typeof(num2) !== 'number'){ //Проверяем, если хоть один аргумент не число
//       reject(new Error('Нужно передать в функцию числа!'))      //Переводим промис в состояние Rejected
//     }
//     resolve(num1 + num2);                                       //Если проверка прошла, складываем 2 числа и
//   })                                                            //Переводим промис в состояние Fulfilled
// }
// add('1', 2)                                                     //Вызываем функцию, передав один аргумент str
//   .then((result) => console.log(result))                        //Не пройдет по условию, уйдет в reject
//   .catch((e) => console.log(e.message))                         //Будет выведенно сообщение об ошибке
//   .finally(() => console.log('Промис завершен.'));              //В любом случае будет выведено
// //Output -> Нужно передать в функцию числа! Промис завершен.
// add(5, 5)                                                       //Взываем, передав все верно
//   .then((result) => console.log(result))                        //Резолвим, выводим сумму
//   .catch((e) => console.log(e.message))                         //Сюда не попадем
//   .finally(() => console.log('Промис завершен.'));              //В любом случае будет выведено
// //Output - 10. Промис завершен.