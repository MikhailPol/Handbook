/*
Дженерики в языке программирования - это возможность создавать обобщенные типы данных или функции, которые могут работать с различными типами, а не только с одним конкретным типом данных. Они позволяют создавать собственные типы, которые могут принимать параметры типа во время использования.

Дженерики предоставляют следующие преимущества:

1. Повышение безопасности типов: Дженерики позволяют обеспечить типовую безопасность во время компиляции. Вы можете указывать ожидаемый тип данных для обобщенных параметров, а компилятор будет заботиться о проверке типов при использовании дженериков.

2. Повторное использование кода: Дженерики позволяют создавать обобщенные компоненты, которые могут быть использованы с разными типами данных. Это позволяет избежать дублирования кода и повысить эффективность разработки.

3. Гибкость и абстракция: Дженерики позволяют создавать абстрактные типы данных, которые могут работать со множеством различных типов. Это способствует созданию более гибкого кода, который может быть использован в различных сценариях.

Некоторые примеры использования дженериков включают контейнеры данных, такие как списки или стеки, обобщенные функции, обобщенные классы и интерфейсы. Дженерики также широко применяются в стандартных библиотеках языков программирования, чтобы обеспечить гибкость и переиспользование кода.
*/

// Обычная функция с дженериками
function gen<T>(args: T): T {
  return args
}
gen<number>(1) // вызываем функцию с числами
gen<string>('1') // вызываем функцию со строками

// Стрелочная функция с дженериками
const gen2 = <T>(args: T): T => {
  return args
}
gen2<string>('123'); // вызываем функцию со строками
gen2<number>(123) // вызываем функцию с числами;

// Класс с дженериками
class Channel<T> {
  private name: T

  constructor(name: T) {
    this.name = name
  }

  getName(): T {
    return this.name
  }
}
new Channel<string>('asda')// создаем экземпляр класса с типом имени строка
new Channel<number>(123)// создаем экземпляр класса с типом имени число

// Интерфейс с дженериком
interface Ipair<K, V> {
  key: K
  value: V
} // key будет типа К value типа V
const pair1: Ipair<number, string> = {
  key: 1,
  value: 'hey'
} // key - число value - строка
const pair2: Ipair<string, number> = {
  key: 'hey',
  value: 1
} // key - строка value - число

// Тип дженерика по умолчанию
type TypeLength = {
  length: number
}

function getNameLength<T extends TypeLength>(entity: T): number {
  return entity.length
}

getNameLength('121') // Вернет длину строки
getNameLength([1, 2, '3', true]) // Вернет длину массива